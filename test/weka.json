[	{		"source" : "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * JSONNode.java\n * Copyright (C) 2009-2012 University of Waikato, Hamilton, New Zealand\n */\n\npackage weka.core.json;\n\nimport java_cup.runtime.DefaultSymbolFactory;\nimport java_cup.runtime.SymbolFactory;\n\nimport javax.swing.JFrame;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTree;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport java.awt.BorderLayout;\nimport java.io.Reader;\n\n/**\n * Container class for storing a\n * <a href=\"http://www.json.org/\" target=\"_blank\">JSON</a> data structure.\n * \n * @author FracPete (fracpete at waikato dot ac dot nz)\n * @version $Revision$\n */\npublic class JSONNode extends DefaultMutableTreeNode {\n\n  /** for serialization. */\n  private static final long serialVersionUID = -3047440914507883491L;\n\n  /**\n   * The type of a node.\n   * \n   * @author FracPete (fracpete at waikato dot ac dot nz)\n   * @version $Revision$\n   */\n  public static enum NodeType {\n    /** a primitive. */\n    PRIMITIVE, /** an object with nested key-value pairs. */\n    OBJECT, /** an array. */\n    ARRAY\n  }\n\n  /** the name of the node. */\n  protected String m_Name;\n\n  /** the value of the node. */\n  protected Object m_Value;\n\n  /** the type of the node. */\n  protected NodeType m_NodeType;\n\n  /**\n   * Initializes the root container.\n   */\n  public JSONNode() {\n    this(null, NodeType.OBJECT);\n  }\n\n  /**\n   * Initializes the primitive container.\n   * \n   * @param name the name\n   * @param value the primitive value\n   */\n  public JSONNode(String name, Boolean value) {\n    this(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Initializes the primitive container.\n   * \n   * @param name the name\n   * @param value the primitive value\n   */\n  public JSONNode(String name, Integer value) {\n    this(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Initializes the primitive container.\n   * \n   * @param name the name\n   * @param value the primitive value\n   */\n  public JSONNode(String name, Double value) {\n    this(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Initializes the primitive container.\n   * \n   * @param name the name\n   * @param value the primitive value\n   */\n  public JSONNode(String name, String value) {\n    this(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Initializes the object container with null value.\n   * \n   * @param name the name\n   * @param type the node type\n   */\n  protected JSONNode(String name, NodeType type) {\n    this(name, null, type);\n  }\n\n  /**\n   * Initializes the container.\n   * \n   * @param name the name\n   * @param value the primitive value\n   * @param type the type of the node, null for primitives\n   */\n  protected JSONNode(String name, Object value, NodeType type) {\n    super();\n\n    m_Name = name;\n    m_Value = value;\n    m_NodeType = type;\n  }\n\n  /**\n   * Checks whether the node is anonymous.\n   * \n   * @return true if no name available\n   */\n  public boolean isAnonymous() {\n    return (m_Name == null);\n  }\n\n  /**\n   * Returns the name of the node.\n   * \n   * @return the name, null for anonymous nodes\n   */\n  public String getName() {\n    return m_Name;\n  }\n\n  /**\n   * Returns the stored value.\n   * \n   * @return the stored value, can be null\n   */\n  public Object getValue() {\n    return getValue(null);\n  }\n\n  /**\n   * Returns the stored value.\n   * \n   * @param defValue the default value, if value is null\n   * @return the stored value, can be null\n   */\n  public Object getValue(Object defValue) {\n    if (m_Value == null) {\n      return defValue;\n    } else {\n      if (m_Value instanceof String) {\n        return unescape(m_Value.toString());\n      } else {\n        return m_Value;\n      }\n    }\n  }\n\n  /**\n   * Returns whether the node stores a primitive value or a an array/object.\n   * \n   * @return true if a primitive, false in case of an array/object\n   */\n  public boolean isPrimitive() {\n    return (m_NodeType == NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Returns wether the node is an array.\n   * \n   * @return true if the node is array container\n   */\n  public boolean isArray() {\n    return (m_NodeType == NodeType.ARRAY);\n  }\n\n  /**\n   * Returns wether the node is an object.\n   * \n   * @return true if the node is object container\n   */\n  public boolean isObject() {\n    return (m_NodeType == NodeType.OBJECT);\n  }\n\n  /**\n   * Returns the type of the container.\n   * \n   * @return the type\n   */\n  public NodeType getNodeType() {\n    return m_NodeType;\n  }\n\n  /**\n   * Adds a \"null\" child to the object.\n   * \n   * @param name the name of the null value\n   * @return the new node, or null if none added\n   */\n  public JSONNode addNull(String name) {\n    return add(name, null, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Adds a key-value child to the object.\n   * \n   * @param name the name of the pair\n   * @param value the value\n   * @return the new node, or null if none added\n   */\n  public JSONNode addPrimitive(String name, Boolean value) {\n    return add(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Adds a key-value child to the object.\n   * \n   * @param name the name of the pair\n   * @param value the value\n   * @return the new node, or null if none added\n   */\n  public JSONNode addPrimitive(String name, Integer value) {\n    return add(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Adds a key-value child to the object.\n   * \n   * @param name the name of the pair\n   * @param value the value\n   * @return the new node, or null if none added\n   */\n  public JSONNode addPrimitive(String name, Double value) {\n    return add(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Adds a key-value child to the object.\n   * \n   * @param name the name of the pair\n   * @param value the value\n   * @return the new node, or null if none added\n   */\n  public JSONNode addPrimitive(String name, String value) {\n    return add(name, value, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Adds an array child to the object.\n   * \n   * @param name the name of the pair\n   * @return the new node, or null if none added\n   */\n  public JSONNode addArray(String name) {\n    return add(name, null, NodeType.ARRAY);\n  }\n\n  /**\n   * Adds a null array element child to the array.\n   * \n   * @return the new node, or null if none added\n   */\n  public JSONNode addNullArrayElement() {\n    return add(null, null, NodeType.PRIMITIVE);\n  }\n\n  /**\n   * Add a key-value object child into the array\n   * \n   * @return the newly added node\n   */\n  public JSONNode addObjectArrayElement() {\n    return add(null, null, NodeType.OBJECT);\n  }\n\n  /**\n   * Adds an array element child to the array.\n   * \n   * @param value the value of the element array\n   * @return the new node, or null if none added\n   */\n  public JSONNode addArrayElement(Object value) {\n    NodeType type;\n\n    if (getNodeType() != NodeType.ARRAY) {\n      return null;\n    }\n\n    type = null;\n\n    if (value != null) {\n      if (value instanceof Boolean) {\n        type = NodeType.PRIMITIVE;\n      } else if (value instanceof Integer) {\n        type = NodeType.PRIMITIVE;\n      } else if (value instanceof Double) {\n        type = NodeType.PRIMITIVE;\n      } else if (value instanceof String) {\n        type = NodeType.PRIMITIVE;\n      } else if (value.getClass().isArray()) {\n        type = NodeType.ARRAY;\n      } else {\n        type = NodeType.OBJECT;\n      }\n    }\n\n    return add(null, value, type);\n  }\n\n  /**\n   * Adds an object child to the object.\n   * \n   * @param name the name of the pair\n   * @return the new node, or null if none added\n   */\n  public JSONNode addObject(String name) {\n    return add(name, null, NodeType.OBJECT);\n  }\n\n  /**\n   * Adds a key-value child to the object.\n   * \n   * @param name the name of the pair\n   * @param value the value\n   * @param type the node type, null for primitives\n   * @return the new node, or null if none added\n   */\n  protected JSONNode add(String name, Object value, NodeType type) {\n    JSONNode child;\n\n    if (isPrimitive()) {\n      return null;\n    }\n\n    child = new JSONNode(name, value, type);\n    add(child);\n\n    return child;\n  }\n\n  /**\n   * Checks whether the node has a child with the given name.\n   * \n   * @param name the name of the child\n   * @return true if child with that name is available\n   */\n  public boolean hasChild(String name) {\n    return (getChild(name) != null);\n  }\n\n  /**\n   * Returns the child with the given name.\n   * \n   * @param name the name of the child\n   * @return the child if available, null otherwise\n   */\n  public JSONNode getChild(String name) {\n    JSONNode result;\n    JSONNode node;\n    int i;\n\n    result = null;\n\n    for (i = 0; i < getChildCount(); i++) {\n      node = (JSONNode) getChildAt(i);\n      if (!node.isAnonymous() && node.getName().equals(name)) {\n        result = node;\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Generates the indentation string.\n   * \n   * @param level the level\n   * @return the indentation string (tabs)\n   */\n  protected String getIndentation(int level) {\n    StringBuffer result;\n    int i;\n\n    result = new StringBuffer();\n    for (i = 0; i < level; i++) {\n      result.append(\"\\t\");\n    }\n\n    return result.toString();\n  }\n\n  /**\n   * Escapes \", \\, /, \\b, \\f, \\n, \\r, \\t in strings.\n   * \n   * @param o the object to process (only strings get processed)\n   * @return the processed object\n   */\n  protected Object escape(Object o) {\n    if (o instanceof String) {\n      return escape((String) o);\n    } else {\n      return o;\n    }\n  }\n\n  /**\n   * Escapes \", /, \\b, \\f, \\n, \\r, \\t.\n   *\n   * @param s the string to process\n   * @return the processed\n   */\n  protected String escape(String s) {\n    StringBuffer result;\n    int i;\n    char c;\n\n    // take care of already escaped characters first (like\n    // \\n in string literals\n    // kind of ugly - probably a better way of handling this\n    // somehow.\n    s = s.replace(\"\\\\n\", \"@@-@@n\").replace(\"\\\\r\", \"@@-@@r\")\n      .replace(\"\\\\t\", \"@@-@@t\").replace(\"\\\\b\", \"@@-@@b\")\n      .replace(\"\\\\f\", \"@@-@@f\");\n\n    if ((s.indexOf('\\\"') > -1) || (s.indexOf('\\\\') > -1)\n      || (s.indexOf('\\b') > -1) || (s.indexOf('\\f') > -1)\n      || (s.indexOf('\\n') > -1) || (s.indexOf('\\r') > -1)\n      || (s.indexOf('\\t') > -1)) {\n      result = new StringBuffer();\n      for (i = 0; i < s.length(); i++) {\n        c = s.charAt(i);\n        if (c == '\\\"') {\n          result.append(\"\\\\\\\"\");\n        } else if (c == '\\\\') {\n          result.append(\"\\\\\\\\\");\n        } else if (c == '\\b') {\n          result.append(\"\\\\b\");\n        } else if (c == '\\f') {\n          result.append(\"\\\\f\");\n        } else if (c == '\\n') {\n          result.append(\"\\\\n\");\n        } else if (c == '\\r') {\n          result.append(\"\\\\r\");\n        } else if (c == '\\t') {\n          result.append(\"\\\\t\");\n        } else {\n          result.append(c);\n        }\n      }\n    } else {\n      result = new StringBuffer(s);\n    }\n\n    return result.toString();\n  }\n\n  /**\n   * Un-escapes \", /, \\b, \\f, \\n, \\r, \\t.\n   *\n   * @param s the string to process\n   * @return the processed string\n   */\n  protected String unescape(String s) {\n    StringBuilder newStringBuffer;\n    int index;\n\n    // replace each of the following characters with the backquoted version\n    String charsFind[] = { \"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\b\", \"\\\\f\",\n      \"\\\\\\\"\", \"\\\\%\", \"\\\\u001E\" };\n    char charsReplace[] =\n      { '\\\\', '\\'', '\\t', '\\n', '\\r', '\\b', '\\f', '\"', '%', '\\u001E' };\n    int pos[] = new int[charsFind.length];\n    int curPos;\n\n    String str = new String(s);\n    newStringBuffer = new StringBuilder();\n    while (str.length() > 0) {\n      // get positions and closest character to replace\n      curPos = str.length();\n      index = -1;\n      for (int i = 0; i < pos.length; i++) {\n        pos[i] = str.indexOf(charsFind[i]);\n        if ((pos[i] > -1) && (pos[i] < curPos)) {\n          index = i;\n          curPos = pos[i];\n        }\n      }\n\n      // replace character if found, otherwise finished\n      if (index == -1) {\n        newStringBuffer.append(str);\n        str = \"\";\n      } else {\n        newStringBuffer.append(str.substring(0, pos[index]));\n        newStringBuffer.append(charsReplace[index]);\n        str = str.substring(pos[index] + charsFind[index].length());\n      }\n    }\n\n    return newStringBuffer.toString().replace(\"@@-@@\", \"\\\\\");\n  }\n\n  /**\n   * Dumps the node structure into JSON format.\n   * \n   * @param buffer the buffer to add the data to\n   */\n  public void toString(StringBuffer buffer) {\n    int level;\n    boolean isLast;\n    String indent;\n    int i;\n\n    level = getLevel();\n    isLast = (getNextSibling() == null);\n    indent = getIndentation(level);\n\n    buffer.append(indent);\n    if (m_Name != null) {\n      buffer.append(\"\\\"\");\n      buffer.append(escape(m_Name));\n      buffer.append(\"\\\" : \");\n    }\n\n    if (isObject()) {\n      buffer.append(\"{\\n\");\n      for (i = 0; i < getChildCount(); i++) {\n        ((JSONNode) getChildAt(i)).toString(buffer);\n      }\n      buffer.append(indent);\n      buffer.append(\"}\");\n    } else if (isArray()) {\n      buffer.append(\"[\\n\");\n      for (i = 0; i < getChildCount(); i++) {\n        ((JSONNode) getChildAt(i)).toString(buffer);\n      }\n      buffer.append(indent);\n      buffer.append(\"]\");\n    } else {\n      if (m_Value == null) {\n        buffer.append(\"null\");\n      } else if (m_Value instanceof String) {\n        buffer.append(\"\\\"\");\n        buffer.append(escape((String) m_Value));\n        buffer.append(\"\\\"\");\n      } else {\n        buffer.append(m_Value.toString());\n      }\n    }\n\n    if (!isLast) {\n      buffer.append(\",\");\n    }\n    buffer.append(\"\\n\");\n  }\n\n  /**\n   * Returns a string representation of the node.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    String result;\n\n    result = null;\n\n    if (isObject()) {\n      if (isRoot()) {\n        result = \"JSON\";\n      } else if (m_Name == null) {\n        result = \"<object>\";\n      } else {\n        result = escape(m_Name) + \" (Object)\";\n      }\n    } else if (isArray()) {\n      if (m_Name == null) {\n        result = \"<array>\";\n      } else {\n        result = escape(m_Name) + \" (Array)\";\n      }\n    } else {\n      if (m_Name != null) {\n        result = escape(m_Name) + \": \" + escape(m_Value);\n      } else {\n        result = \"\" + m_Value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Reads the JSON object from the given reader.\n   * \n   * @param reader the reader to read the JSON object from\n   * @return the generated JSON object\n   * @throws Exception if parsing fails\n   */\n  @SuppressWarnings(\"deprecation\")\n  public static JSONNode read(Reader reader) throws Exception {\n    SymbolFactory sf;\n    Parser parser;\n\n    sf = new DefaultSymbolFactory();\n    parser = new Parser(new Scanner(reader, sf), sf);\n    parser.parse();\n\n    return parser.getResult();\n  }\n\n  /**\n   * Only for testing. Generates a simple JSON object and displays it.\n   * \n   * @param args ignored\n   * @throws Exception if something goes wrong\n   */\n  public static void main(String[] args) throws Exception {\n    // generates the example listed here:\n    // http://en.wikipedia.org/wiki/JSON\n    JSONNode person = new JSONNode();\n    person.addPrimitive(\"firstName\", \"John\");\n    person.addPrimitive(\"lastName\", \"Smith\");\n    JSONNode address = person.addObject(\"address\");\n    address.addPrimitive(\"streetAddress\", \"21 2nd Street\");\n    address.addPrimitive(\"city\", \"New York\");\n    address.addPrimitive(\"state\", \"NY\");\n    address.addPrimitive(\"postalCode\", 10021);\n    JSONNode phonenumbers = person.addArray(\"phoneNumbers\");\n    phonenumbers.addArrayElement(\"212 555-1234\");\n    phonenumbers.addArrayElement(\"646 555-4567\");\n\n    // output in console\n    StringBuffer buffer = new StringBuffer();\n    person.toString(buffer);\n    System.out.println(buffer.toString());\n\n    // display GUI\n    JTree tree = new JTree(person);\n    JFrame frame = new JFrame(\"JSON\");\n    frame.setSize(800, 600);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.getContentPane().setLayout(new BorderLayout());\n    frame.getContentPane().add(new JScrollPane(tree), BorderLayout.CENTER);\n    frame.setLocationRelativeTo(null);\n    frame.setVisible(true);\n  }\n}\n",		"parent" : "DefaultMutableTreeNode",		"relations" : [			"JSONNode",			"Parser",			"Scanner"		],		"name" : "JSONNode",		"type" : "class"	},	{		"source" : "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * JSONInstances.java\n * Copyright (C) 2009-2012 University of Waikato, Hamilton, New Zealand\n */\n\npackage weka.core.json;\n\nimport java.util.ArrayList;\n\nimport weka.core.Attribute;\nimport weka.core.DenseInstance;\nimport weka.core.Instance;\nimport weka.core.Instances;\nimport weka.core.SparseInstance;\nimport weka.core.Utils;\nimport weka.core.converters.ConverterUtils.DataSource;\n\n/**\n * Class for transforming Instances objects into <a href=\"http://www.json.org/\" target=\"_blank\">JSON</a>\n * objects and vice versa. Missing values get stored as \"?\".\n * \n * @author  FracPete (fracpete at waikato dot ac dot nz)\n * @version $Revision$\n * @see #MISSING_VALUE\n */\npublic class JSONInstances {\n\n  /** the header section. */\n  public final static String HEADER = \"header\";\n\n  /** the data section. */\n  public final static String DATA = \"data\";\n\n  /** the relation name. */\n  public final static String RELATION = \"relation\";\n\n  /** the attributes object. */\n  public final static String ATTRIBUTES = \"attributes\";\n\n  /** the name attribute. */\n  public final static String NAME = \"name\";\n\n  /** the type attribute. */\n  public final static String TYPE = \"type\";\n\n  /** the class attribute indicator. */\n  public final static String CLASS = \"class\";\n\n  /** the labels attribute. */\n  public final static String LABELS = \"labels\";\n\n  /** the weight attribute. */\n  public final static String WEIGHT = \"weight\";\n\n  /** the dateformat attribute. */\n  public final static String DATEFORMAT = \"dateformat\";\n\n  /** the sparse attribute. */\n  public final static String SPARSE = \"sparse\";\n\n  /** the values attribute. */\n  public final static String VALUES = \"values\";\n\n  /** the separator for index/value in case of sparse instances. */\n  public final static String SPARSE_SEPARATOR = \":\";\n\n  /** the missing value indicator. */\n  public final static String MISSING_VALUE = \"?\";\n  \n  /**\n   * Turns the JSON object into an Attribute, if possible.\n   * \n   * @param att\t\tthe JSON object to turn into an Attribute\n   * @param classAtt\tfor storing whether the attribute is the class attribute\n   * @return\t\tthe Attribute, null in case of an error\n   */\n  protected static Attribute toAttribute(JSONNode att, boolean[] classAtt) {\n    Attribute\t\tresult;\n    String\t\tname;\n    String\t\ttype;\n    String\t\tdateformat;\n    JSONNode\t\tlabels;\n    ArrayList<String>\tvalues;\n    String\t\tlabel;\n    int\t\t\ti;\n    double\t\tweight;\n    \n    name   = (String) att.getChild(NAME).getValue(\"noname\");\n    type   = (String) att.getChild(TYPE).getValue(\"\");\n    weight = (Double) att.getChild(WEIGHT).getValue(new Double(1.0));\n    if (type.equals(Attribute.typeToString(Attribute.NUMERIC))) {\n      result = new Attribute(name);\n    }\n    else if (type.equals(Attribute.typeToString(Attribute.NOMINAL))) {\n      labels = att.getChild(LABELS);\n      values = new ArrayList<String>();\n      for (i = 0; i < labels.getChildCount(); i++) {\n\tlabel = (String)((JSONNode) labels.getChildAt(i)).getValue();\n\tif (label.equals(\"'\" + MISSING_VALUE + \"'\"))\n\t  values.add(MISSING_VALUE);\n\telse\n\t  values.add(label);\n      }\n      result = new Attribute(name, values);\n    }\n    else if (type.equals(Attribute.typeToString(Attribute.DATE))) {\n      dateformat = (String) att.getChild(DATEFORMAT).getValue(\"yyyy-MM-dd'T'HH:mm:ss\");\n      result     = new Attribute(name, dateformat);\n    }\n    else if (type.equals(Attribute.typeToString(Attribute.STRING))) {\n      result = new Attribute(name, (ArrayList<String>) null);\n    }\n    else {\n      System.err.println(\"Unhandled attribute type '\" + type + \"'!\");\n      return null;\n    }\n    result.setWeight(weight);\n    \n    return result;\n  }\n\n  /**\n   * Turns the JSON Object into an Instance, if possible.\n   * \n   * @param inst\tthe JSON object to turn into an Instance\n   * @param data\tthe data so far (only used for header information)\n   * @return\t\tthe Instance, null in case of an error\n   */\n  protected static Instance toInstance(JSONNode inst, Instances data) {\n    Instance\tresult;\n    boolean\tsparse;\n    double\tweight;\n    JSONNode\tvalues;\n    int\t\ti;\n    int\t\tindex;\n    int\t\tpos;\n    String\tvalue;\n    double[]\tvals;\n\n    sparse = (Boolean) inst.getChild(SPARSE).getValue(new Boolean(false));\n    weight = (Double) inst.getChild(WEIGHT).getValue(new Double(1.0));\n    values = inst.getChild(VALUES);\n    vals   = new double[data.numAttributes()];\n    for (i = 0; i < values.getChildCount(); i++) {\n      if (sparse) {\n\tvalue = \"\" + ((JSONNode) values.getChildAt(i)).getValue();\n\tpos   = value.indexOf(SPARSE_SEPARATOR);\n\tindex = Integer.parseInt(value.substring(0, pos));\n\tvalue = value.substring(pos + 1);\n      }\n      else {\n\tindex = i;\n\tvalue = \"\" + ((JSONNode) values.getChildAt(i)).getValue();\n      }\n      \n      try {\n\tif (value.equals(MISSING_VALUE)) {\n\t  vals[index] = Utils.missingValue();\n\t}\n\telse {\n\t  // unescape '?' labels \n\t  if (value.equals(\"'\" + MISSING_VALUE + \"'\"))\n\t    value = MISSING_VALUE;\n\t  if (data.attribute(index).isNumeric() && !data.attribute(index).isDate()) {\n\t    vals[index] = Double.parseDouble(value);\n\t  }\n\t  else if (data.attribute(index).isNominal()) {\n\t    vals[index] = data.attribute(index).indexOfValue(value);\n\t    if ((vals[index] == -1) && value.startsWith(\"'\") && value.endsWith(\"'\"))\n\t      vals[index] = data.attribute(index).indexOfValue(Utils.unquote(value));\n\t    // FIXME backslashes seem to get escaped twice when creating a JSON file?\n\t    if ((vals[index] == -1) && value.startsWith(\"'\") && value.endsWith(\"'\"))\n\t      vals[index] = data.attribute(index).indexOfValue(Utils.unbackQuoteChars(Utils.unquote(value)));\n\t    if (vals[index] == -1) {\n\t      System.err.println(\"Unknown label '\" + value + \"' for attribute #\" + (index+1) + \"!\");\n\t      return null;\n\t    }\n\t  }\n\t  else if (data.attribute(index).isDate()) {\n\t    vals[index] = data.attribute(index).parseDate(value);\n\t  }\n\t  else if (data.attribute(index).isString()) {\n\t    vals[index] = data.attribute(index).addStringValue(value);\n\t  }\n\t  else {\n\t    System.err.println(\"Unhandled attribute type '\" + Attribute.typeToString(data.attribute(index).type()) + \"'!\");\n\t    return null;\n\t  }\n\t}\n      }\n      catch (Exception e) {\n\tSystem.err.println(\"Error parsing value #\" + (index+1) + \": \" + e.toString());\n\treturn null;\n      }\n    }\n\n    if (sparse)\n      result = new SparseInstance(weight, vals);\n    else\n      result = new DenseInstance(weight, vals);\n    result.setDataset(data);\n      \n    return result;\n  }\n  \n  /**\n   * Turns a JSON object, if possible, into an Instances object.\n   * \n   * @param json\tthe JSON object to convert\n   * @param onlyHeader\twhether to retrieve only the header\n   * @return\t\tthe generated Instances object, null if not possible\n   */\n  protected static Instances toInstances(JSONNode json, boolean onlyHeader) {\n    Instances\tresult;\n    JSONNode\theader;\n    JSONNode\tattributes;\n    JSONNode\tdata;\n    ArrayList<Attribute>\tatts;\n    Attribute\tatt;\n    Instance\tinst;\n    int\t\ti;\n    int\t\tclassIndex;\n    boolean[]\tclassAtt;\n    \n    header = json.getChild(HEADER);\n    if (header == null) {\n      System.err.println(\"No '\" + HEADER + \"' section!\");\n      return null;\n    }\n    data = json.getChild(DATA);\n    if (data == null) {\n      System.err.println(\"No '\" + DATA + \"' section!\");\n      return null;\n    }\n    \n    // attributes\n    attributes = header.getChild(ATTRIBUTES);\n    if (attributes == null) {\n      System.err.println(\"No '\" + ATTRIBUTES + \"' array!\");\n      return null;\n    }\n    atts       = new ArrayList<Attribute>();\n    classAtt   = new boolean[1];\n    classIndex = -1;\n    for (i = 0; i < attributes.getChildCount(); i++) {\n      att = toAttribute((JSONNode) attributes.getChildAt(i), classAtt);\n      if (att == null) {\n\tSystem.err.println(\"Could not convert attribute #\" + (i+1) + \"!\");\n\treturn null;\n      }\n      if (classAtt[0])\n\tclassIndex = i;\n      atts.add(att);\n    }\n    result = new Instances(\n\theader.getChild(RELATION).getValue(\"unknown\").toString(), \n\tatts, \n\t(onlyHeader ? 0 : data.getChildCount()));\n    result.setClassIndex(classIndex);\n    \n    // data\n    if (!onlyHeader) {\n      for (i = 0; i < data.getChildCount(); i++) {\n\tinst = toInstance((JSONNode) data.getChildAt(i), result);\n\tif (inst == null) {\n\t  System.err.println(\"Could not convert instance #\" + (i+1) + \"!\");\n\t  return null;\n\t}\n\tresult.add(inst);\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Turns a JSON object, if possible, into an Instances object.\n   * \n   * @param json\tthe JSON object to convert\n   * @return\t\tthe generated Instances object, null if not possible\n   */\n  public static Instances toInstances(JSONNode json) {\n    return toInstances(json, false);\n  }\n  \n  /**\n   * Turns a JSON object, if possible, into an Instances object (only header).\n   * \n   * @param json\tthe JSON object to convert\n   * @return\t\tthe generated Instances header object, null if not possible\n   */\n  public static Instances toHeader(JSONNode json) {\n    return toInstances(json, true);\n  }\n  \n  /**\n   * Turns the Attribute into a JSON object.\n   * \n   * @param inst\tthe corresponding dataset\n   * @param att\t\tthe attribute to convert\n   * @return\t\tthe JSON object\n   */\n  protected static JSONNode toJSON(Instances inst, Attribute att) {\n    JSONNode\tresult;\n    JSONNode\tlabels;\n    int\t\ti;\n    \n    result = new JSONNode();\n\n    result.addPrimitive(NAME, att.name());\n    result.addPrimitive(TYPE, Attribute.typeToString(att));\n    result.addPrimitive(CLASS, (att.index() == inst.classIndex()));\n    result.addPrimitive(WEIGHT, att.weight());\n    if (att.isNominal()) {\n      labels = result.addArray(LABELS);\n      for (i = 0; i < att.numValues(); i++) {\n\tif (att.value(i).equals(MISSING_VALUE))\n\t  labels.addArrayElement(\"'\" + att.value(i) + \"'\");\n\telse\n\t  labels.addArrayElement(att.value(i));\n      }\n    }\n    if (att.isDate())\n      result.addPrimitive(DATEFORMAT, att.getDateFormat());\n    \n    return result;\n  }\n  \n  /**\n   * Turns the Instance into a JSON object.\n   * \n   * @param inst\tthe Instance to convert\n   * @return\t\tthe JSON object\n   */\n  protected static JSONNode toJSON(Instance inst) {\n    JSONNode\tresult;\n    JSONNode\tvalues;\n    int\t\ti;\n    boolean\tsparse;\n    \n    result = new JSONNode();\n    \n    sparse = (inst instanceof SparseInstance);\n    result.addPrimitive(SPARSE, sparse);\n    result.addPrimitive(WEIGHT, inst.weight());\n    values = result.addArray(VALUES);\n    if (sparse) {\n      for (i = 0; i < inst.numValues(); i++) {\n\tif (inst.isMissing(inst.index(i)))\n\t  values.addArrayElement(inst.index(i) + SPARSE_SEPARATOR + MISSING_VALUE);\n\telse if (inst.toString(inst.index(i)).equals(\"'\" + MISSING_VALUE + \"'\"))\n\t  values.addArrayElement(inst.index(i) + SPARSE_SEPARATOR + \"'\" + MISSING_VALUE + \"'\");  // escape '?' labels\n\telse\n\t  values.addArrayElement(inst.index(i) + SPARSE_SEPARATOR + inst.toString(inst.index(i)));\n      }\n    }\n    else {\n      for (i = 0; i < inst.numAttributes(); i++) {\n\tif (inst.isMissing(i))\n\t  values.addArrayElement(MISSING_VALUE);\n\telse if (inst.toString(i).equals(\"'\" + MISSING_VALUE + \"'\"))\n\t  values.addArrayElement(\"'\" + MISSING_VALUE + \"'\");  // escape '?' labels\n\telse\n\t  values.addArrayElement(inst.toString(i));\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Turns the Instances object into a JSON object.\n   * \n   * @param inst\tthe Instances to turn into a JSON object\n   * @return\t\tthe JSON object\n   */\n  public static JSONNode toJSON(Instances inst) {\n    JSONNode\tresult;\n    JSONNode\theader;\n    JSONNode\tatts;\n    JSONNode\tdata;\n    int\t\ti;\n    \n    result = new JSONNode();\n    \n    // header\n    header = result.addObject(HEADER);\n    header.addPrimitive(RELATION, inst.relationName());\n    atts = header.addArray(ATTRIBUTES);\n    for (i = 0; i < inst.numAttributes(); i++)\n      atts.add(toJSON(inst, inst.attribute(i)));\n    \n    // data\n    data = result.addArray(DATA);\n    for (i = 0; i < inst.numInstances(); i++)\n      data.add(toJSON(inst.instance(i)));\n    \n    return result;\n  }\n  \n  /**\n   * For testing only.\n   * \n   * @param args\texpects a dataset as first parameter\n   * @throws Exception\tif something goes wrong\n   */\n  public static void main(String[] args) throws Exception {\n    if (args.length != 1) {\n      System.err.println(\"No dataset supplied!\");\n      System.exit(1);\n    }\n\n    // load dataset\n    Instances data = DataSource.read(args[0]);\n    \n    // turn Instances into JSON object and output it\n    JSONNode json = toJSON(data);\n    StringBuffer buffer = new StringBuffer();\n    json.toString(buffer);\n    System.out.println(buffer.toString());\n    \n    // turn JSON object back into Instances and output it\n    Instances inst = toInstances(json);\n    System.out.println(inst);\n  }\n}\n",		"name" : "JSONInstances",		"relations" : [			"JSONNode",			"JSONInstances"		],		"type" : "class"	},	{		"source" : "\n//----------------------------------------------------\n// The following code was generated by CUP v0.11b 20141202 (SVN rev 60)\n//----------------------------------------------------\n\npackage weka.core.json;\n\nimport java_cup.runtime.*;\nimport java.io.*;\nimport java.util.*;\nimport java_cup.runtime.XMLElement;\n\n/** CUP v0.11b 20141202 (SVN rev 60) generated parser.\n  */\n@SuppressWarnings({\"rawtypes\"})\npublic class Parser extends java_cup.runtime.lr_parser {\n\n public final Class getSymbolContainer() {\n    return sym.class;\n}\n\n  /** Default constructor. */\n  public Parser() {super();}\n\n  /** Constructor which sets the default scanner. */\n  public Parser(java_cup.runtime.Scanner s) {super(s);}\n\n  /** Constructor which sets the default scanner. */\n  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}\n\n  /** Production table. */\n  protected static final short _production_table[][] = \n    unpackFromStrings(new String[] {\n    \"\\000\\053\\000\\002\\002\\004\\000\\002\\002\\004\\000\\002\\002\" +\n    \"\\005\\000\\002\\003\\005\\000\\002\\003\\003\\000\\002\\004\\003\" +\n    \"\\000\\002\\004\\003\\000\\002\\004\\003\\000\\002\\005\\003\\000\" +\n    \"\\002\\005\\003\\000\\002\\005\\003\\000\\002\\005\\003\\000\\002\" +\n    \"\\005\\003\\000\\002\\006\\005\\000\\002\\007\\005\\000\\002\\010\" +\n    \"\\005\\000\\002\\011\\005\\000\\002\\012\\005\\000\\002\\014\\004\" +\n    \"\\000\\002\\014\\005\\000\\002\\015\\005\\000\\002\\013\\004\\000\" +\n    \"\\002\\013\\005\\000\\002\\016\\003\\000\\002\\017\\003\\000\\002\" +\n    \"\\020\\003\\000\\002\\022\\004\\000\\002\\022\\005\\000\\002\\023\" +\n    \"\\005\\000\\002\\021\\004\\000\\002\\021\\005\\000\\002\\024\\003\" +\n    \"\\000\\002\\025\\003\\000\\002\\026\\003\\000\\002\\027\\005\\000\" +\n    \"\\002\\027\\003\\000\\002\\030\\003\\000\\002\\030\\003\\000\\002\" +\n    \"\\030\\003\\000\\002\\030\\003\\000\\002\\030\\003\\000\\002\\030\" +\n    \"\\003\\000\\002\\030\\003\" });\n\n  /** Access to production table. */\n  public short[][] production_table() {return _production_table;}\n\n  /** Parse-action table. */\n  protected static final short[][] _action_table = \n    unpackFromStrings(new String[] {\n    \"\\000\\073\\000\\004\\007\\005\\001\\002\\000\\004\\002\\075\\001\" +\n    \"\\002\\000\\006\\010\\020\\016\\014\\001\\002\\000\\006\\004\\062\" +\n    \"\\010\\074\\001\\002\\000\\006\\010\\060\\016\\014\\001\\002\\000\" +\n    \"\\022\\005\\035\\006\\043\\007\\051\\012\\042\\013\\041\\014\\037\" +\n    \"\\015\\047\\016\\045\\001\\002\\000\\006\\004\\ufffd\\010\\ufffd\\001\" +\n    \"\\002\\000\\006\\004\\ufffb\\010\\ufffb\\001\\002\\000\\006\\004\\ufff7\" +\n    \"\\010\\ufff7\\001\\002\\000\\004\\011\\024\\001\\002\\000\\006\\004\" +\n    \"\\ufff9\\010\\ufff9\\001\\002\\000\\006\\004\\ufffc\\010\\ufffc\\001\\002\" +\n    \"\\000\\006\\004\\ufff5\\010\\ufff5\\001\\002\\000\\004\\002\\001\\001\" +\n    \"\\002\\000\\006\\004\\ufff6\\010\\ufff6\\001\\002\\000\\006\\004\\ufffa\" +\n    \"\\010\\ufffa\\001\\002\\000\\006\\004\\ufff8\\010\\ufff8\\001\\002\\000\" +\n    \"\\020\\005\\025\\007\\031\\012\\032\\013\\033\\014\\026\\015\\027\" +\n    \"\\016\\030\\001\\002\\000\\022\\005\\uffe5\\006\\uffe5\\007\\uffe5\\012\" +\n    \"\\uffe5\\013\\uffe5\\014\\uffe5\\015\\uffe5\\016\\uffe5\\001\\002\\000\\006\" +\n    \"\\004\\ufff2\\010\\ufff2\\001\\002\\000\\006\\004\\ufff1\\010\\ufff1\\001\" +\n    \"\\002\\000\\006\\004\\ufff0\\010\\ufff0\\001\\002\\000\\006\\010\\uffed\" +\n    \"\\016\\uffed\\001\\002\\000\\006\\004\\ufff4\\010\\ufff4\\001\\002\\000\" +\n    \"\\006\\004\\ufff3\\010\\ufff3\\001\\002\\000\\006\\004\\067\\006\\uffe1\" +\n    \"\\001\\002\\000\\022\\005\\uffe2\\006\\uffe2\\007\\uffe2\\012\\uffe2\\013\" +\n    \"\\uffe2\\014\\uffe2\\015\\uffe2\\016\\uffe2\\001\\002\\000\\022\\005\\035\" +\n    \"\\006\\043\\007\\051\\012\\042\\013\\041\\014\\037\\015\\047\\016\" +\n    \"\\045\\001\\002\\000\\006\\004\\uffdb\\006\\uffdb\\001\\002\\000\\006\" +\n    \"\\004\\uffe7\\010\\uffe7\\001\\002\\000\\006\\004\\uffdc\\006\\uffdc\\001\" +\n    \"\\002\\000\\006\\004\\uffdd\\006\\uffdd\\001\\002\\000\\010\\004\\uffe0\" +\n    \"\\006\\uffe0\\010\\uffe0\\001\\002\\000\\006\\004\\uffde\\006\\uffde\\001\" +\n    \"\\002\\000\\006\\004\\uffd9\\006\\uffd9\\001\\002\\000\\006\\010\\060\" +\n    \"\\016\\014\\001\\002\\000\\006\\004\\uffda\\006\\uffda\\001\\002\\000\" +\n    \"\\004\\006\\043\\001\\002\\000\\006\\010\\uffea\\016\\uffea\\001\\002\" +\n    \"\\000\\006\\004\\uffd7\\006\\uffd7\\001\\002\\000\\006\\004\\uffd8\\006\" +\n    \"\\uffd8\\001\\002\\000\\006\\004\\uffe6\\010\\uffe6\\001\\002\\000\\006\" +\n    \"\\004\\062\\010\\uffe9\\001\\002\\000\\004\\010\\060\\001\\002\\000\" +\n    \"\\006\\004\\uffec\\006\\uffec\\001\\002\\000\\010\\004\\uffe8\\006\\uffe8\" +\n    \"\\010\\uffe8\\001\\002\\000\\006\\004\\uffeb\\006\\uffeb\\001\\002\\000\" +\n    \"\\004\\016\\014\\001\\002\\000\\006\\004\\ufffe\\010\\ufffe\\001\\002\" +\n    \"\\000\\006\\004\\uffe4\\006\\uffe4\\001\\002\\000\\004\\006\\043\\001\" +\n    \"\\002\\000\\006\\004\\uffe3\\006\\uffe3\\001\\002\\000\\020\\005\\035\" +\n    \"\\007\\051\\012\\042\\013\\041\\014\\037\\015\\047\\016\\045\\001\" +\n    \"\\002\\000\\006\\004\\uffdf\\006\\uffdf\\001\\002\\000\\004\\010\\060\" +\n    \"\\001\\002\\000\\006\\004\\uffef\\010\\uffef\\001\\002\\000\\006\\004\" +\n    \"\\uffee\\010\\uffee\\001\\002\\000\\004\\002\\uffff\\001\\002\\000\\004\" +\n    \"\\002\\000\\001\\002\" });\n\n  /** Access to parse-action table. */\n  public short[][] action_table() {return _action_table;}\n\n  /** <code>reduce_goto</code> table. */\n  protected static final short[][] _reduce_table = \n    unpackFromStrings(new String[] {\n    \"\\000\\073\\000\\004\\002\\003\\001\\001\\000\\002\\001\\001\\000\" +\n    \"\\032\\003\\005\\004\\010\\005\\015\\006\\014\\007\\022\\010\\012\" +\n    \"\\011\\020\\012\\016\\014\\011\\015\\006\\022\\021\\023\\007\\001\" +\n    \"\\001\\000\\002\\001\\001\\000\\036\\003\\054\\004\\010\\005\\015\" +\n    \"\\006\\014\\007\\022\\010\\012\\011\\020\\012\\016\\014\\011\\015\" +\n    \"\\006\\017\\070\\020\\071\\022\\021\\023\\007\\001\\001\\000\\022\" +\n    \"\\013\\052\\016\\045\\021\\051\\024\\035\\025\\047\\026\\037\\027\" +\n    \"\\033\\030\\043\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\" +\n    \"\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\" +\n    \"\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\" +\n    \"\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\" +\n    \"\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\" +\n    \"\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\" +\n    \"\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\\022\" +\n    \"\\013\\052\\016\\045\\021\\051\\024\\035\\025\\064\\026\\063\\027\" +\n    \"\\033\\030\\043\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\" +\n    \"\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\" +\n    \"\\002\\001\\001\\000\\002\\001\\001\\000\\036\\003\\054\\004\\010\" +\n    \"\\005\\015\\006\\014\\007\\022\\010\\012\\011\\020\\012\\016\\014\" +\n    \"\\011\\015\\006\\017\\055\\020\\056\\022\\021\\023\\007\\001\\001\" +\n    \"\\000\\002\\001\\001\\000\\004\\026\\053\\001\\001\\000\\002\\001\" +\n    \"\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\" +\n    \"\\000\\002\\001\\001\\000\\004\\020\\060\\001\\001\\000\\002\\001\" +\n    \"\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\\030\\004\\062\" +\n    \"\\005\\015\\006\\014\\007\\022\\010\\012\\011\\020\\012\\016\\014\" +\n    \"\\011\\015\\006\\022\\021\\023\\007\\001\\001\\000\\002\\001\\001\" +\n    \"\\000\\002\\001\\001\\000\\004\\026\\065\\001\\001\\000\\002\\001\" +\n    \"\\001\\000\\014\\013\\052\\016\\045\\021\\051\\024\\035\\030\\067\" +\n    \"\\001\\001\\000\\002\\001\\001\\000\\004\\020\\072\\001\\001\\000\" +\n    \"\\002\\001\\001\\000\\002\\001\\001\\000\\002\\001\\001\\000\\002\" +\n    \"\\001\\001\" });\n\n  /** Access to <code>reduce_goto</code> table. */\n  public short[][] reduce_table() {return _reduce_table;}\n\n  /** Instance of action encapsulation class. */\n  protected CUP$Parser$actions action_obj;\n\n  /** Action encapsulation object initializer. */\n  protected void init_actions()\n    {\n      action_obj = new CUP$Parser$actions(this);\n    }\n\n  /** Invoke a user supplied parse action. */\n  public java_cup.runtime.Symbol do_action(\n    int                        act_num,\n    java_cup.runtime.lr_parser parser,\n    java.util.Stack            stack,\n    int                        top)\n    throws java.lang.Exception\n  {\n    /* call code in generated class */\n    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);\n  }\n\n  /** Indicates start state. */\n  public int start_state() {return 0;}\n  /** Indicates start production. */\n  public int start_production() {return 1;}\n\n  /** <code>EOF</code> Symbol index. */\n  public int EOF_sym() {return 0;}\n\n  /** <code>error</code> Symbol index. */\n  public int error_sym() {return 1;}\n\n\n  /** User initialization code. */\n  public void user_init() throws java.lang.Exception\n    {\n\n  m_Symbols = new HashMap();\n  m_Result  = new JSONNode();\n  m_Stack   = new Stack<JSONNode>();\n  m_Stack.push(m_Result);\n\n    }\n\n\n  /** variable - value relation. */\n  protected HashMap m_Symbols;\n\n  /** for storing the parsed JSON data structure. */\n  protected JSONNode m_Result;\n  \n  /** the stack for keeping track of the current parent node. */\n  protected Stack<JSONNode> m_Stack;\n\n  /**\n   * Returns the JSON data structure.\n   * \n   * @return the result\n   */\n  public JSONNode getResult() {\n    return m_Result;\n  }\n  \n  /**\n   * Returns the stack used internally for keeping track of the current\n   * parent node.\n   * \n   * @return the stack\n   */\n  protected Stack<JSONNode> getStack() {\n    return m_Stack;\n  }\n\n  /**\n   * Runs the parser from commandline. Expects a filename as first parameter,\n   * pointing to a JSON file.\n   * \n   * @param args the commandline arguments\n   * @throws Exception if something goes wrong\n   */\n  public static void main(String args[]) throws Exception {\n    if (args.length != 1) {\n      System.err.println(\"No JSON file specified!\");\n      System.exit(1);\n    }\n    \n    FileInputStream stream = new FileInputStream(args[0]);\n    SymbolFactory sf = new DefaultSymbolFactory();\n    Parser parser = new Parser(new Scanner(stream, sf), sf);\n    parser.parse();\n    StringBuffer buffer = new StringBuffer();\n    parser.getResult().toString(buffer);\n    System.out.println(buffer.toString());\n  }\n\n\n/** Cup generated class to encapsulate user supplied action code.*/\n@SuppressWarnings({\"rawtypes\", \"unchecked\", \"unused\"})\nclass CUP$Parser$actions {\n  private final Parser parser;\n\n  /** Constructor */\n  CUP$Parser$actions(Parser parser) {\n    this.parser = parser;\n  }\n\n  /** Method 0 with the actual generated action code for actions 0 to 300. */\n  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(\n    int                        CUP$Parser$act_num,\n    java_cup.runtime.lr_parser CUP$Parser$parser,\n    java.util.Stack            CUP$Parser$stack,\n    int                        CUP$Parser$top)\n    throws java.lang.Exception\n    {\n      /* Symbol object for return from actions */\n      java_cup.runtime.Symbol CUP$Parser$result;\n\n      /* select the action based on the action number */\n      switch (CUP$Parser$act_num)\n        {\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 0: // json ::= LCURLY RCURLY \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"json\",0, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 1: // $START ::= json EOF \n            {\n              Object RESULT =null;\n\t\tObject start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;\n\t\tRESULT = start_val;\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"$START\",0, RESULT);\n            }\n          /* ACCEPT */\n          CUP$Parser$parser.done_parsing();\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 2: // json ::= LCURLY pairs RCURLY \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"json\",0, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 3: // pairs ::= pairs COMMA pair \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"pairs\",1, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 4: // pairs ::= pair \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"pairs\",1, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 5: // pair ::= primitive \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"pair\",2, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 6: // pair ::= named_object \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"pair\",2, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 7: // pair ::= named_array \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"pair\",2, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 8: // primitive ::= null \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"primitive\",3, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 9: // primitive ::= boolean \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"primitive\",3, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 10: // primitive ::= integer \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"primitive\",3, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 11: // primitive ::= double \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"primitive\",3, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 12: // primitive ::= string \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"primitive\",3, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 13: // null ::= STRING COLON NULL \n            {\n              Object RESULT =null;\n\t\tString name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;\n\t\t \n                          parser.getStack().peek().addNull(name);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"null\",4, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 14: // boolean ::= STRING COLON BOOLEAN \n            {\n              Boolean RESULT =null;\n\t\tString name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;\n\t\tBoolean b = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t\n                          parser.getStack().peek().addPrimitive(name, b);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"boolean\",5, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 15: // integer ::= STRING COLON INTEGER \n            {\n              Integer RESULT =null;\n\t\tString name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;\n\t\tInteger i = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t\n                          parser.getStack().peek().addPrimitive(name, i);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"integer\",6, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 16: // double ::= STRING COLON DOUBLE \n            {\n              Double RESULT =null;\n\t\tString name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;\n\t\tDouble d = (Double)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t\n                          parser.getStack().peek().addPrimitive(name, d);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"double\",7, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 17: // string ::= STRING COLON STRING \n            {\n              String RESULT =null;\n\t\tString name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;\n\t\tString s = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t \n                          parser.getStack().peek().addPrimitive(name, s);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"string\",8, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 18: // named_object ::= named_object_start object_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"named_object\",10, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 19: // named_object ::= named_object_start object_content object_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"named_object\",10, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 20: // named_object_start ::= STRING COLON LCURLY \n            {\n              Object RESULT =null;\n\t\tString name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;\n\t\t\n                          JSONNode node = parser.getStack().peek().addObject(name);\n                          parser.getStack().push(node);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"named_object_start\",11, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 21: // anon_object ::= anon_object_start object_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"anon_object\",9, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 22: // anon_object ::= anon_object_start object_content object_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"anon_object\",9, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 23: // anon_object_start ::= LCURLY \n            {\n              Object RESULT =null;\n\t\t\n                          JSONNode node = parser.getStack().peek().addObject(null);\n                          parser.getStack().push(node);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"anon_object_start\",12, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 24: // object_content ::= pairs \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"object_content\",13, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 25: // object_end ::= RCURLY \n            {\n              Object RESULT =null;\n\t\t\n                          parser.getStack().pop();\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"object_end\",14, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 26: // named_array ::= named_array_start array_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"named_array\",16, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 27: // named_array ::= named_array_start array_content array_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"named_array\",16, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 28: // named_array_start ::= STRING COLON LSQUARE \n            {\n              Object RESULT =null;\n\t\tString name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;\n\t\t\n                          JSONNode node = parser.getStack().peek().addArray(name);\n                          parser.getStack().push(node);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"named_array_start\",17, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 29: // anon_array ::= anon_array_start array_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"anon_array\",15, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 30: // anon_array ::= anon_array_start array_content array_end \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"anon_array\",15, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 31: // anon_array_start ::= LSQUARE \n            {\n              Object RESULT =null;\n\t\t\n                          JSONNode node = parser.getStack().peek().addArray(null);\n                          parser.getStack().push(node);\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"anon_array_start\",18, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 32: // array_content ::= elements \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"array_content\",19, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 33: // array_end ::= RSQUARE \n            {\n              Object RESULT =null;\n\t\t\n                          parser.getStack().pop();\n                       \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"array_end\",20, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 34: // elements ::= elements COMMA element \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"elements\",21, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 35: // elements ::= element \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"elements\",21, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 36: // element ::= NULL \n            {\n              Object RESULT =null;\n\t\t \n                            parser.getStack().peek().addArrayElement(null);\n                         \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"element\",22, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 37: // element ::= BOOLEAN \n            {\n              Object RESULT =null;\n\t\tBoolean b = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t \n                            parser.getStack().peek().addArrayElement(b);\n                         \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"element\",22, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 38: // element ::= INTEGER \n            {\n              Object RESULT =null;\n\t\tInteger i = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t\n                            parser.getStack().peek().addArrayElement(i);\n                         \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"element\",22, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 39: // element ::= DOUBLE \n            {\n              Object RESULT =null;\n\t\tDouble d = (Double)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t\n                            parser.getStack().peek().addArrayElement(d);\n                         \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"element\",22, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 40: // element ::= STRING \n            {\n              Object RESULT =null;\n\t\tString s = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;\n\t\t \n                            parser.getStack().peek().addArrayElement(s);\n                         \n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"element\",22, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 41: // element ::= anon_object \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"element\",22, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /*. . . . . . . . . . . . . . . . . . . .*/\n          case 42: // element ::= anon_array \n            {\n              Object RESULT =null;\n\n              CUP$Parser$result = parser.getSymbolFactory().newSymbol(\"element\",22, RESULT);\n            }\n          return CUP$Parser$result;\n\n          /* . . . . . .*/\n          default:\n            throw new Exception(\n               \"Invalid action number \"+CUP$Parser$act_num+\"found in internal parse table\");\n\n        }\n    } /* end of method */\n\n  /** Method splitting the generated action code into several parts. */\n  public final java_cup.runtime.Symbol CUP$Parser$do_action(\n    int                        CUP$Parser$act_num,\n    java_cup.runtime.lr_parser CUP$Parser$parser,\n    java.util.Stack            CUP$Parser$stack,\n    int                        CUP$Parser$top)\n    throws java.lang.Exception\n    {\n              return CUP$Parser$do_action_part00000000(\n                               CUP$Parser$act_num,\n                               CUP$Parser$parser,\n                               CUP$Parser$stack,\n                               CUP$Parser$top);\n    }\n}\n\n}\n",		"parent" : "java_cup.runtime.lr_parser",		"relations" : [			"JSONNode",			"Parser",			"Scanner",			"sym"		],		"name" : "Parser",		"type" : "class"	},	{		"source" : "/* The following code was generated by JFlex 1.6.0 */\n\n/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * Scanner.java\n * Copyright (C) 2009-2012 University of Waikato, Hamilton, New Zealand\n */\n\npackage weka.core.json;\n\nimport java_cup.runtime.SymbolFactory;\nimport java.io.*;\n\n/**\n * A scanner for JSON data files.\n *\n * @author FracPete (fracpete at waikato dot ac dot nz)\n * @version $Revision$\n */\n\npublic class Scanner implements java_cup.runtime.Scanner {\n\n  /** This character denotes the end of file */\n  public static final int YYEOF = -1;\n\n  /** initial size of the lookahead buffer */\n  private static final int ZZ_BUFFERSIZE = 16384;\n\n  /** lexical states */\n  public static final int YYINITIAL = 0;\n  public static final int STRING = 2;\n\n  /**\n   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l\n   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l\n   *                  at the beginning of a line\n   * l is of the form l = 2*k, k a non negative integer\n   */\n  private static final int ZZ_LEXSTATE[] = { \n     0,  0,  1, 1\n  };\n\n  /** \n   * Translates characters to character classes\n   */\n  private static final char [] ZZ_CMAP = {\n     0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 24,  0, 20, 22,  0,  0, \n     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, \n    20,  0, 19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5, 18, 17,  0, \n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  6,  0,  0,  0,  0,  0, \n     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, \n     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3, 21,  4,  0,  0, \n     0, 14, 23,  0,  0, 12, 13,  0,  0,  0,  0,  0,  9,  0,  7,  0, \n     0,  0, 11, 15, 10,  8,  0,  0,  0,  0,  0,  1,  0,  2,  0,  0\n  };\n\n  /** \n   * Translates DFA states to action switch labels.\n   */\n  private static final int [] ZZ_ACTION = zzUnpackAction();\n\n  private static final String ZZ_ACTION_PACKED_0 =\n    \"\\2\\0\\1\\1\\1\\2\\1\\3\\1\\4\\1\\5\\1\\6\\1\\7\"+\n    \"\\3\\1\\1\\10\\1\\1\\1\\11\\1\\12\\1\\13\\1\\14\\1\\15\"+\n    \"\\3\\0\\2\\16\\1\\17\\1\\20\\1\\21\\1\\22\\1\\23\\1\\24\"+\n    \"\\3\\0\\1\\25\\1\\26\";\n\n  private static int [] zzUnpackAction() {\n    int [] result = new int[35];\n    int offset = 0;\n    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackAction(String packed, int offset, int [] result) {\n    int i = 0;       /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int count = packed.charAt(i++);\n      int value = packed.charAt(i++);\n      do result[j++] = value; while (--count > 0);\n    }\n    return j;\n  }\n\n\n  /** \n   * Translates a state to a row index in the transition table\n   */\n  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();\n\n  private static final String ZZ_ROWMAP_PACKED_0 =\n    \"\\0\\0\\0\\31\\0\\62\\0\\62\\0\\62\\0\\62\\0\\62\\0\\62\"+\n    \"\\0\\62\\0\\113\\0\\144\\0\\175\\0\\226\\0\\257\\0\\62\\0\\62\"+\n    \"\\0\\310\\0\\62\\0\\341\\0\\372\\0\\u0113\\0\\u012c\\0\\u0145\\0\\u015e\"+\n    \"\\0\\62\\0\\62\\0\\62\\0\\62\\0\\62\\0\\62\\0\\u0177\\0\\u0190\"+\n    \"\\0\\u01a9\\0\\62\\0\\62\";\n\n  private static int [] zzUnpackRowMap() {\n    int [] result = new int[35];\n    int offset = 0;\n    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackRowMap(String packed, int offset, int [] result) {\n    int i = 0;  /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int high = packed.charAt(i++) << 16;\n      result[j++] = high | packed.charAt(i++);\n    }\n    return j;\n  }\n\n  /** \n   * The transition table of the DFA\n   */\n  private static final int [] ZZ_TRANS = zzUnpackTrans();\n\n  private static final String ZZ_TRANS_PACKED_0 =\n    \"\\1\\3\\1\\4\\1\\5\\1\\6\\1\\7\\1\\10\\1\\11\\1\\12\"+\n    \"\\2\\3\\1\\13\\2\\3\\1\\14\\2\\3\\1\\15\\1\\3\\1\\16\"+\n    \"\\1\\17\\1\\20\\1\\3\\1\\20\\1\\3\\1\\20\\23\\21\\1\\22\"+\n    \"\\1\\21\\1\\23\\1\\3\\1\\21\\42\\0\\1\\24\\33\\0\\1\\25\"+\n    \"\\33\\0\\1\\26\\32\\0\\1\\15\\1\\27\\27\\0\\1\\30\\10\\0\"+\n    \"\\23\\21\\1\\0\\1\\21\\2\\0\\1\\21\\10\\0\\1\\31\\2\\0\"+\n    \"\\1\\32\\1\\33\\1\\0\\1\\34\\5\\0\\1\\35\\3\\0\\1\\36\"+\n    \"\\12\\0\\1\\37\\27\\0\\1\\40\\31\\0\\1\\41\\37\\0\\1\\27\"+\n    \"\\30\\0\\1\\30\\1\\27\\20\\0\\1\\42\\33\\0\\1\\43\\33\\0\"+\n    \"\\1\\40\\11\\0\";\n\n  private static int [] zzUnpackTrans() {\n    int [] result = new int[450];\n    int offset = 0;\n    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackTrans(String packed, int offset, int [] result) {\n    int i = 0;       /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int count = packed.charAt(i++);\n      int value = packed.charAt(i++);\n      value--;\n      do result[j++] = value; while (--count > 0);\n    }\n    return j;\n  }\n\n\n  /* error codes */\n  private static final int ZZ_UNKNOWN_ERROR = 0;\n  private static final int ZZ_NO_MATCH = 1;\n  private static final int ZZ_PUSHBACK_2BIG = 2;\n\n  /* error messages for the codes above */\n  private static final String ZZ_ERROR_MSG[] = {\n    \"Unkown internal scanner error\",\n    \"Error: could not match input\",\n    \"Error: pushback value was too large\"\n  };\n\n  /**\n   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>\n   */\n  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();\n\n  private static final String ZZ_ATTRIBUTE_PACKED_0 =\n    \"\\2\\0\\7\\11\\5\\1\\2\\11\\1\\1\\1\\11\\1\\1\\3\\0\"+\n    \"\\2\\1\\6\\11\\3\\0\\2\\11\";\n\n  private static int [] zzUnpackAttribute() {\n    int [] result = new int[35];\n    int offset = 0;\n    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackAttribute(String packed, int offset, int [] result) {\n    int i = 0;       /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int count = packed.charAt(i++);\n      int value = packed.charAt(i++);\n      do result[j++] = value; while (--count > 0);\n    }\n    return j;\n  }\n\n  /** the input device */\n  private java.io.Reader zzReader;\n\n  /** the current state of the DFA */\n  private int zzState;\n\n  /** the current lexical state */\n  private int zzLexicalState = YYINITIAL;\n\n  /** this buffer contains the current text to be matched and is\n      the source of the yytext() string */\n  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];\n\n  /** the textposition at the last accepting state */\n  private int zzMarkedPos;\n\n  /** the current text position in the buffer */\n  private int zzCurrentPos;\n\n  /** startRead marks the beginning of the yytext() string in the buffer */\n  private int zzStartRead;\n\n  /** endRead marks the last character in the buffer, that has been read\n      from input */\n  private int zzEndRead;\n\n  /** number of newlines encountered up to the start of the matched text */\n  private int yyline;\n\n  /** the number of characters up to the start of the matched text */\n  private int yychar;\n\n  /**\n   * the number of characters from the last newline up to the start of the \n   * matched text\n   */\n  private int yycolumn;\n\n  /** \n   * zzAtBOL == true <=> the scanner is currently at the beginning of a line\n   */\n  private boolean zzAtBOL = true;\n\n  /** zzAtEOF == true <=> the scanner is at the EOF */\n  private boolean zzAtEOF;\n\n  /** denotes if the user-EOF-code has already been executed */\n  private boolean zzEOFDone;\n  \n  /** \n   * The number of occupied positions in zzBuffer beyond zzEndRead.\n   * When a lead/high surrogate has been read from the input stream\n   * into the final zzBuffer position, this will have a value of 1;\n   * otherwise, it will have a value of 0.\n   */\n  private int zzFinalHighSurrogate = 0;\n\n  /* user code: */\n  // Author: FracPete (fracpete at waikato dot ac dot nz)\n  // Version: $Revision$\n  protected SymbolFactory m_SF;\n\n  protected StringBuffer m_String = new StringBuffer();\n\n  public Scanner(InputStream r, SymbolFactory sf) {\n    this(new InputStreamReader(r));\n    m_SF = sf;\n  }\n\n  public Scanner(Reader r, SymbolFactory sf) {\n    this(r);\n    m_SF = sf;\n  }\n\n\n  /**\n   * Creates a new scanner\n   *\n   * @param   in  the java.io.Reader to read input from.\n   */\n  public Scanner(java.io.Reader in) {\n    this.zzReader = in;\n  }\n\n\n\n  /**\n   * Refills the input buffer.\n   *\n   * @return      <code>false</code>, iff there was new input.\n   * \n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private boolean zzRefill() throws java.io.IOException {\n\n    /* first: make room (if you can) */\n    if (zzStartRead > 0) {\n      zzEndRead += zzFinalHighSurrogate;\n      zzFinalHighSurrogate = 0;\n      System.arraycopy(zzBuffer, zzStartRead,\n                       zzBuffer, 0,\n                       zzEndRead-zzStartRead);\n\n      /* translate stored positions */\n      zzEndRead-= zzStartRead;\n      zzCurrentPos-= zzStartRead;\n      zzMarkedPos-= zzStartRead;\n      zzStartRead = 0;\n    }\n\n    /* is the buffer big enough? */\n    if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) {\n      /* if not: blow it up */\n      char newBuffer[] = new char[zzBuffer.length*2];\n      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);\n      zzBuffer = newBuffer;\n      zzEndRead += zzFinalHighSurrogate;\n      zzFinalHighSurrogate = 0;\n    }\n\n    /* fill the buffer with new input */\n    int requested = zzBuffer.length - zzEndRead;           \n    int totalRead = 0;\n    while (totalRead < requested) {\n      int numRead = zzReader.read(zzBuffer, zzEndRead + totalRead, requested - totalRead);\n      if (numRead == -1) {\n        break;\n      }\n      totalRead += numRead;\n    }\n\n    if (totalRead > 0) {\n      zzEndRead += totalRead;\n      if (totalRead == requested) { /* possibly more input available */\n        if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {\n          --zzEndRead;\n          zzFinalHighSurrogate = 1;\n        }\n      }\n      return false;\n    }\n\n    // totalRead = 0: End of stream\n    return true;\n  }\n\n    \n  /**\n   * Closes the input stream.\n   */\n  public final void yyclose() throws java.io.IOException {\n    zzAtEOF = true;            /* indicate end of file */\n    zzEndRead = zzStartRead;  /* invalidate buffer    */\n\n    if (zzReader != null)\n      zzReader.close();\n  }\n\n\n  /**\n   * Resets the scanner to read from a new input stream.\n   * Does not close the old reader.\n   *\n   * All internal variables are reset, the old input stream \n   * <b>cannot</b> be reused (internal buffer is discarded and lost).\n   * Lexical state is set to <tt>ZZ_INITIAL</tt>.\n   *\n   * Internal scan buffer is resized down to its initial length, if it has grown.\n   *\n   * @param reader   the new input stream \n   */\n  public final void yyreset(java.io.Reader reader) {\n    zzReader = reader;\n    zzAtBOL  = true;\n    zzAtEOF  = false;\n    zzEOFDone = false;\n    zzEndRead = zzStartRead = 0;\n    zzCurrentPos = zzMarkedPos = 0;\n    zzFinalHighSurrogate = 0;\n    yyline = yychar = yycolumn = 0;\n    zzLexicalState = YYINITIAL;\n    if (zzBuffer.length > ZZ_BUFFERSIZE)\n      zzBuffer = new char[ZZ_BUFFERSIZE];\n  }\n\n\n  /**\n   * Returns the current lexical state.\n   */\n  public final int yystate() {\n    return zzLexicalState;\n  }\n\n\n  /**\n   * Enters a new lexical state\n   *\n   * @param newState the new lexical state\n   */\n  public final void yybegin(int newState) {\n    zzLexicalState = newState;\n  }\n\n\n  /**\n   * Returns the text matched by the current regular expression.\n   */\n  public final String yytext() {\n    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );\n  }\n\n\n  /**\n   * Returns the character at position <tt>pos</tt> from the \n   * matched text. \n   * \n   * It is equivalent to yytext().charAt(pos), but faster\n   *\n   * @param pos the position of the character to fetch. \n   *            A value from 0 to yylength()-1.\n   *\n   * @return the character at position pos\n   */\n  public final char yycharat(int pos) {\n    return zzBuffer[zzStartRead+pos];\n  }\n\n\n  /**\n   * Returns the length of the matched text region.\n   */\n  public final int yylength() {\n    return zzMarkedPos-zzStartRead;\n  }\n\n\n  /**\n   * Reports an error that occured while scanning.\n   *\n   * In a wellformed scanner (no or only correct usage of \n   * yypushback(int) and a match-all fallback rule) this method \n   * will only be called with things that \"Can't Possibly Happen\".\n   * If this method is called, something is seriously wrong\n   * (e.g. a JFlex bug producing a faulty scanner etc.).\n   *\n   * Usual syntax/scanner level error handling should be done\n   * in error fallback rules.\n   *\n   * @param   errorCode  the code of the errormessage to display\n   */\n  private void zzScanError(int errorCode) {\n    String message;\n    try {\n      message = ZZ_ERROR_MSG[errorCode];\n    }\n    catch (ArrayIndexOutOfBoundsException e) {\n      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];\n    }\n\n    throw new Error(message);\n  } \n\n\n  /**\n   * Pushes the specified amount of characters back into the input stream.\n   *\n   * They will be read again by then next call of the scanning method\n   *\n   * @param number  the number of characters to be read again.\n   *                This number must not be greater than yylength()!\n   */\n  public void yypushback(int number)  {\n    if ( number > yylength() )\n      zzScanError(ZZ_PUSHBACK_2BIG);\n\n    zzMarkedPos -= number;\n  }\n\n\n  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public java_cup.runtime.Symbol next_token() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { System.err.println(\"Illegal character: \" + yytext());\n          }\n        case 23: break;\n        case 2: \n          { return m_SF.newSymbol(\"Left curly bracket\", sym.LCURLY);\n          }\n        case 24: break;\n        case 3: \n          { return m_SF.newSymbol(\"Right curly bracket\", sym.RCURLY);\n          }\n        case 25: break;\n        case 4: \n          { return m_SF.newSymbol(\"Left square bracket\", sym.LSQUARE);\n          }\n        case 26: break;\n        case 5: \n          { return m_SF.newSymbol(\"Right square bracket\", sym.RSQUARE);\n          }\n        case 27: break;\n        case 6: \n          { return m_SF.newSymbol(\"Comma\", sym.COMMA);\n          }\n        case 28: break;\n        case 7: \n          { return m_SF.newSymbol(\"Colon\", sym.COLON);\n          }\n        case 29: break;\n        case 8: \n          { return m_SF.newSymbol(\"Integer\", sym.INTEGER, new Integer(yytext()));\n          }\n        case 30: break;\n        case 9: \n          { m_String.setLength(0); yybegin(STRING);\n          }\n        case 31: break;\n        case 10: \n          { /* ignore white space. */\n          }\n        case 32: break;\n        case 11: \n          { m_String.append(yytext());\n          }\n        case 33: break;\n        case 12: \n          { yybegin(YYINITIAL); return m_SF.newSymbol(\"String\", sym.STRING, m_String.toString());\n          }\n        case 34: break;\n        case 13: \n          { m_String.append('\\\\');\n          }\n        case 35: break;\n        case 14: \n          { return m_SF.newSymbol(\"Double\", sym.DOUBLE, new Double(yytext()));\n          }\n        case 36: break;\n        case 15: \n          { m_String.append('\\n');\n          }\n        case 37: break;\n        case 16: \n          { m_String.append('\\t');\n          }\n        case 38: break;\n        case 17: \n          { m_String.append('\\r');\n          }\n        case 39: break;\n        case 18: \n          { m_String.append('\\f');\n          }\n        case 40: break;\n        case 19: \n          { m_String.append('\\\"');\n          }\n        case 41: break;\n        case 20: \n          { m_String.append('\\b');\n          }\n        case 42: break;\n        case 21: \n          { return m_SF.newSymbol(\"Null\", sym.NULL);\n          }\n        case 43: break;\n        case 22: \n          { return m_SF.newSymbol(\"Boolean\", sym.BOOLEAN, new Boolean(yytext()));\n          }\n        case 44: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {     return m_SF.newSymbol(\"EOF\", sym.EOF);\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n\n}\n",		"name" : "Scanner",		"relations" : [			"Scanner",			"sym"		],		"type" : "class"	},	{		"source" : "\n//----------------------------------------------------\n// The following code was generated by CUP v0.11b 20141202 (SVN rev 60)\n//----------------------------------------------------\n\npackage weka.core.json;\n\n/** CUP generated interface containing symbol constants. */\npublic interface sym {\n  /* terminals */\n  public static final int LSQUARE = 3;\n  public static final int INTEGER = 10;\n  public static final int COLON = 7;\n  public static final int BOOLEAN = 9;\n  public static final int NULL = 8;\n  public static final int RSQUARE = 4;\n  public static final int STRING = 12;\n  public static final int EOF = 0;\n  public static final int DOUBLE = 11;\n  public static final int error = 1;\n  public static final int COMMA = 2;\n  public static final int RCURLY = 6;\n  public static final int LCURLY = 5;\n  public static final String[] terminalNames = new String[] {\n  \"EOF\",\n  \"error\",\n  \"COMMA\",\n  \"LSQUARE\",\n  \"RSQUARE\",\n  \"LCURLY\",\n  \"RCURLY\",\n  \"COLON\",\n  \"NULL\",\n  \"BOOLEAN\",\n  \"INTEGER\",\n  \"DOUBLE\",\n  \"STRING\"\n  };\n}\n\n",		"name" : "sym",		"relations" : [			"sym"		],		"type" : "interface"	}]